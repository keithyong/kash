README.md
TERM_PROGRAM=iTerm.app
a.out
input.txt
kash.c
practice
test.txt
README.md
TERM_PROGRAM=iTerm.app
a.out
input.txt
kash.c
practice
test.txt
README.md
TERM_PROGRAM=iTerm.app
a.out
input.txt
kash.c
practice
test.txt
//DUE OCTOBER 1st!
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h> 
#include <sys/types.h> 
#include <sys/wait.h> 
#include <errno.h> 
#include <signal.h>
#include <dirent.h>

//Maximum size of number of arguments. 
//Example: "ls | grep input.txt <" has 3 arguments.
#define ARGS_ARRAY_SIZE     20

//How many commands this shell has.
//Only 1 for now unless more custom
//commands are added.

#define COM_LENGTH          1
char *com[COM_LENGTH] = {"exit"};

//Used to split up input around <>| delims
void preParse(char *inputLine);

int parse(char *inputLine, char *arguments[], const char *delimiters);
int findCommand(char *input, char *listOfCommands[], int n);
void forkIt(char *args[]);
void runCommand(int command);
void execToFile(char *args[], char *fileName);

const char *DELIMS = " |<>\n";

#define BUFFER              1024
char line[BUFFER];
char *args[ARGS_ARRAY_SIZE];

//Some inits for the for loops.
int i;
char *p;

int main(){
    while(1){
        printf("kash $ ");
        fgets(line, BUFFER, stdin);
        preParse(line);
        int count = parse(line, args, DELIMS);
        int command = findCommand(args[0], com, COM_LENGTH);
        printf("%d",command);
        runCommand(command); 
    }
}

/*  preParse:
 *  Looks for ">", "<", or "|" and takes appropriate action
 */
void preParse(char *inputLine){
    char *after[3];
    if (strstr(inputLine, ">") != NULL){
        after[0] = strstr(inputLine, ">") + 1;
    }

    if (strstr(inputLine, "<") != NULL){
        after[1] = strstr(inputLine, "<") + 1;
    }

    if (strstr(inputLine, "|") != NULL){
        after[2] = strstr(inputLine, "|") + 1;
    }
}

int parse(char *inputLine, char *arguments[], const char *delimiters)
{
    int count = 0;
    printf("Parsed out: ");
    for (p = strtok(inputLine, delimiters); p != NULL; p = strtok(NULL, delimiters))
    {
        arguments[count] = p;
        printf("[%s]", arguments[count]);
        count++;
    }
    putchar('\n');
    arguments[count]=NULL;
    return count;
}


int findCommand(char *input, char *listOfCommands[], int n){
    for (i = 0; i < n; i++){
        if(strcmp(input, listOfCommands[i]) == 0){
          return i;
        }
    }

    //If no commands are found then return -1
    return -1;
}

void runCommand(int command){
    switch (command){
        case -1:
            forkIt(args);
            break;
        case 0:
            exit(1);
            break;
    }
}

void forkIt(char *args[])
{
    int pid = fork();   //Pretty much spawns a new shell.
    printf("pid of new fork: %d\n", pid);
    if (pid == 0){
        execToFile(args, "test.txt");
        printf("Command not found\n");
        exit(1);        //Exits out of duplicate shell.
    }
    else{
        int status;
        waitpid(pid, &status, WCONTINUED);
    }
}

void execToFile(char *args[], char *fileName){
    int out = open(fileName, O_RDWR|O_CREAT|O_APPEND, 0600);
    int save_out = dup(fileno(stdout));

    if (-1 == dup2(out, fileno(stdout)))
        perror("cannot redirect stdout");
    execvp(args[0], args);
    fflush(stdout); close(out);
    dup2(save_out, fileno(stdout));
    close(save_out);
}
"hello shawn"
[H[2J[H[2J[H[2J[H[2JREADME.md
TERM_PROGRAM=iTerm.app
a.out
input.txt
kash.c
practice
test.txt
README.md
TERM_PROGRAM=iTerm.app
a.out
input.txt
kash.c
practice
test.txt
README.md
TERM_PROGRAM=iTerm.app
a.out
input.txt
kash.c
practice
test.txt
